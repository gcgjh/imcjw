TypeScript 的 tsconfig.json 配置项非常丰富，涵盖文件管理、类型检查、编译输出、模块解析、环境适配等所有维度。以下是按功能分类的完整配置项清单，包含每个配置的作用、默认值和核心使用场景（新手重点关注「高频核心配置」即可）。
一、顶层配置（非 compilerOptions 下的全局配置）
这些配置直接写在 tsconfig.json 根节点，用于管理项目范围和编译行为：
配置名	作用	默认值	使用场景
include	指定需要编译的文件 / 目录（支持通配符 */**）	[]	例：["src/**/*.ts"] 匹配 src 下所有 TS 文件
exclude	指定排除编译的文件 / 目录（优先级高于 include）	["node_modules", "bower_components", "jspm_packages"]	排除 dist、*.js 等无需编译的文件
files	显式指定编译的单个文件列表（优先级高于 include）	[]	小型项目直接列出文件，如 ["src/index.ts"]
extends	继承另一个 tsconfig.json 的配置（支持本地 / 远程路径）	-	复用通用配置，例："extends": "./base-tsconfig.json"
references	配置项目引用（用于多模块 / Monorepo 项目）	[]	关联多个子项目，实现增量编译
compileOnSave	编辑器保存文件时自动编译（需编辑器支持）	false	开发时实时编译，避免手动执行 tsc
typeAcquisition	自动获取未安装的类型声明（如 @types/*）	{ "enable": false }	快速调试第三方库，无需手动安装类型
二、compilerOptions 核心配置（按功能分类）
1. 基础 / 核心编译（高频必配）
配置名	作用	默认值	核心说明
strict	开启所有严格类型检查选项（核心开关）	false	新手必开！包含 strictNullChecks/noImplicitAny 等，保证类型安全
target	指定编译后的 JS 目标 ES 版本	ES3	常用：ES6/ES2020/ESNext（兼容运行环境）
module	指定模块系统类型	ES3（或按 target 推断）	常用：ESNext（ESModule）、CommonJS（Node.js）、nodenext（匹配 Node.js 最新规则）
moduleResolution	指定模块解析策略	Classic（旧版）/NodeNext（新版）	常用：NodeNext（适配 Node.js 模块解析）、Node16（兼容 CommonJS/ESModule）
skipLibCheck	跳过 node_modules 中第三方库的类型检查	false	必开！加快编译速度，避免第三方库类型错误阻塞编译
2. 文件布局（隔离源文件 / 产物）
配置名	作用	默认值	核心说明
rootDir	指定 TS 源文件的根目录	自动推断（包含所有源文件的最浅目录）	例："./src"，确保编译产物目录结构和源码一致
outDir	指定编译后 JS 文件的输出目录	源码同目录	例："./dist"，彻底隔离 TS/JS 文件，解决编辑器误报
rootDirs	虚拟合并多个目录为 “根目录”（用于模块解析）	[]	多目录源码合并时使用，如 ["src", "types"]
outFile	将所有编译后的 JS 合并为单个文件（仅支持 AMD/System 模块）	-	旧版前端项目用，现代项目优先用打包工具（webpack）
3. 严格类型检查（strict: true 包含的子选项）
strict: true 会自动开启以下所有子选项，也可单独开启 / 关闭：
配置名	作用	核心说明
strictNullChecks	严格检查 null/undefined	禁止将 null/undefined 赋值给非空类型，例：let a: string = null 报错
noImplicitAny	禁止隐式 any 类型	未指定类型且无法推断时，不再默认 any，必须显式声明
strictFunctionTypes	严格检查函数参数 / 返回值类型	禁止函数类型双向协变（更严格的类型匹配）
strictBindCallApply	严格检查 bind/call/apply 的参数类型	确保函数调用的参数和原函数类型一致
strictPropertyInitialization	要求类属性必须初始化（或在构造函数赋值）	避免类属性未赋值导致 undefined
noImplicitThis	禁止 this 隐式推断为 any	确保 this 有明确的类型
alwaysStrict	编译后的 JS 文件顶部添加 "use strict"	强制 JS 严格模式，避免隐式错误
4. 进阶类型检查（按需开启）
配置名	作用	使用场景	
noUncheckedIndexedAccess	索引访问自动添加 undefined	例：obj[key] 推断为 `T	undefined`，避免访问不存在的索引
exactOptionalPropertyTypes	严格校验可选属性	可选属性仅允许赋值为 undefined，禁止赋值为 null	
noImplicitOverride	子类重写父类方法必须加 override 关键字	避免误写方法名导致 “重写” 变 “新增”	
noPropertyAccessFromIndexSignature	禁止通过索引访问属性（强制点语法）	例：obj['prop'] 报错，必须写 obj.prop，避免拼写错误	
5. 代码输出 / 调试（开发 / 生产适配）
配置名	作用	默认值	使用场景
sourceMap	生成 .js.map 映射文件	false	开发时开启（调试可定位到 TS 源码），生产关闭
declaration	生成 .d.ts 类型声明文件	false	开发库 / 组件时开启（供其他 TS 项目引用类型）
declarationMap	为 .d.ts 生成 sourcemap	false	调试类型声明和源码的关联时开启
removeComments	编译后移除所有注释	false	生产环境开启（减小文件体积）
noEmit	仅检查类型错误，不生成 JS 文件	false	仅验证代码类型时使用（如 CI 检查）
noEmitOnError	有编译错误时不生成 JS 文件	false	必开！避免生成错误的编译产物
emitBOM	输出文件开头添加 UTF-8 BOM	false	仅 Windows 特殊场景需要
6. 模块 / 路径解析（解决导入 / 导出问题）
配置名	作用	默认值	使用场景
baseUrl	指定模块解析的基准目录	项目根目录	配合 paths 实现路径别名，例："./src"
paths	配置模块路径别名（需配合 baseUrl）	{}	例：{"@/*": ["src/*"]}，简化导入 import xxx from "@/utils"
typeRoots	指定类型声明文件的根目录	["node_modules/@types"]	自定义类型声明目录，例：["src/types", "node_modules/@types"]
types	指定仅加载的类型声明包	[]	例：["node"] 仅加载 Node.js 类型（需安装 @types/node）
allowSyntheticDefaultImports	允许对无默认导出的模块使用默认导入	false	兼容 CommonJS 模块，例：import React from "react"
esModuleInterop	兼容 ESModule 和 CommonJS 模块	false	必开！解决 require/export 混用的类型错误
7. JSX/React 相关（前端项目）
配置名	作用	默认值	使用场景
jsx	指定 JSX 语法的编译模式	preserve	常用：
- react-jsx（React 17+ 新转换，无需引入 React）
- react（旧版 React 转换）
- none（禁用 JSX）
jsxFactory	指定 JSX 渲染的工厂函数	React.createElement	自定义 JSX 框架（如 Vue/Preact）时修改
jsxFragmentFactory	指定 JSX 片段的工厂函数	React.Fragment	例：Fragment（适配 Preact）
8. 代码风格 / 错误检查（减少冗余 / 错误）
配置名	作用	默认值	使用场景
noUnusedLocals	禁止声明未使用的局部变量	false	开发时开启，减少代码冗余
noUnusedParameters	禁止声明未使用的函数参数	false	开发时开启，避免无效参数
noImplicitReturns	要求函数所有分支都有显式返回值	false	避免函数隐式返回 undefined
noFallthroughCasesInSwitch	禁止 switch 语句的 case 穿透	false	避免逻辑错误（case 未写 break/return）
noUncheckedSideEffectImports	检查导入语句的副作用	false	禁止无意义的 import 'xxx'（xxx 无副作用）
9. 高级 / 实验性选项（特殊场景）
配置名	作用	默认值	使用场景
isolatedModules	强制每个文件都是独立模块	false	必开！避免全局作用域污染，适配打包工具（webpack/rollup）
verbatimModuleSyntax	强制模块语法字面量（区分类型 / 值导入）	false	例：import type { T } from 'xxx' 必须加 type，避免类型被打包
experimentalDecorators	启用装饰器语法（ES 实验特性）	false	框架（NestJS/Angular）中使用装饰器时开启
emitDecoratorMetadata	为装饰器生成元数据	false	配合装饰器使用（如 NestJS 的依赖注入）
moduleDetection	指定模块检测规则	auto	常用：force（强制所有文件为模块），解决全局变量冲突


三、核心配置总结（新手必配）
无需记住所有配置，新手项目只需配置以下核心项即可满足 90% 场景：
json
{
  "compilerOptions": {
    "strict": true,          // 严格类型检查（核心）
    "target": "ES6",         // 兼容现代环境
    "module": "ESNext",      // 现代模块语法
    "moduleResolution": "NodeNext", // 适配 Node.js 模块解析
    "outDir": "./dist",      // 产物输出目录
    "rootDir": "./src",      // 源码根目录
    "skipLibCheck": true,    // 跳过第三方库类型检查
    "esModuleInterop": true, // 兼容 ES/CommonJS 模块
    "sourceMap": true,       // 开发调试用
    "noEmitOnError": true    // 有错误不生成产物
  },
  "include": ["src/**/*.ts"],
  "exclude": ["node_modules", "./dist"]
}


四、配置查询技巧
官方文档（最全）：https://www.typescriptlang.org/tsconfig
VS Code 中：鼠标悬停在配置名上，会显示官方简短说明；
执行 tsc --showConfig：查看当前项目实际生效的配置（含默认值）。
以上是 tsconfig.json 的完整配置项清单，按功能分类后更易理解，你可根据项目类型（Node.js/ 前端 / 库开发）按需开启对应配置。
